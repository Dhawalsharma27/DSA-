**Given an array of integers arr[] representing a permutation, implement the next permutation that rearranges the numbers into the lexicographically next greater permutation. If no such permutation exists, rearrange the numbers into the lowest possible order (i.e., sorted in ascending order)** 
**Note:  A permutation of an array of integers refers to a specific arrangement of its elements in a sequence or linear order**

Generating Only Next Approach:
Yeh process actually Next Permutation algorithm hai. 
Iska kaam hota hai array ke elements ko use karke agla sabse bada number (lexicographically next greater) dhundhna.
Yaha step-by-step breakdown hai Hinglish mein:1. Pivot find karo (Peeche se)Array ke end se shuru karo aur woh pehla element dhundo jo apne agle element se chota ho ($arr[i] < arr[i + 1]$). 
Is element ko hum pivot kehte hain. Iske baad ka saara hissa "non-increasing" (ghat-te kram mein) hota hai.
Agar Pivot nahi mila?Agar aap poore array mein peeche se shuru tak pahunch gaye aur koi pivot nahi mila (jaise [3, 2, 1]), iska matlab hai array pehle se hi sabse bade order mein hai.
Action: Poore array ko reverse kar do taaki woh sabse chota order ban jaye ([1, 2, 3]).
Successor dhundo aur Swap karoAgar pivot mil gaya hai, toh phir se array ke end se check karo aur woh pehla element dhundo jo pivot se bada ho. Isse hum successor kehte hain.
Action: Pivot aur successor ko aapas mein swap kar do.
Suffix ko Reverse karoSwap karne ke baad, pivot ke index ke baad wala jitna bhi hissa (suffix) hai, use reverse kar do.
Isse woh suffix minimize ho jata hai aur humein just agla bada combination mil jata hai.Example: [1, 2, 4, 3]Find Pivot: Peeche se dekha toh 2 chota hai 4 se.
Toh Pivot = 2 (index 1)
Find Successor: Peeche se 2 se bada pehla element 3 hai.
Toh Successor = 3.Swap: 2 aur 3 ko swap kiya $\rightarrow$ [1, 3, 4, 2].
Reverse Suffix: Pivot index ke baad ka part [4, 2] hai, ise reverse kiya $\rightarrow$ [1, 3, 2, 4].
Final Result: [1, 3, 2, 4]
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
code:
class Solution:
    def nextPermutation(self, arr):
        n = len(arr)
        #intialize pivot as -1 
        pivot = -1
        #loop in reverse order to find the pivot
        for i in range(n-2,-1,-1):
            # this is a reverse loop that start from index n -2 as we have to compare arr[i] with arr[i+1] 
            if arr[i] < arr [i+1]:
                pivot = i
                break
        #   this return the array by reversing it as the next permutation if the pivot is not found i the rverse of the array
        if pivot == -1:
            arr.reverse()
            return
        # Now finding the element from the rightmost of the array which is greater than the pivot and swaping it .
        for j in range(n-1,pivot,-1):
            if arr[j]  > arr[pivot]:
                arr[j] , arr[pivot] = arr[pivot] , arr[j]
                break
        # now reversing the rest array from pivot +1 to end to get the next permutation
        left, right = pivot + 1 , n-1
        while left < right:
            arr[left], arr[right] = arr[right], arr[left]
            left += 1
            right -= 1
            
if __name__ == "__main__":
    
    arr = [2,4,1,7,5,0]
    ob = Solution()
    ob.nextPermutation(arr)
_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Time Complexity: O(n)
Auxiliary Space: O(1)
            
